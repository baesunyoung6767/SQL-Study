## SQL 튜닝 준비하기

SQL문의 구성요소는 크게 두 가지로 구분할 수 있다. <br>
**가시적**으로는 ```테이블 현황과 조건절, 그루핑 열, 정렬되는 열, SELECT 절의 열```이며 **비가시적**으로는 ```실행 계획, 인덱스 현황, 조건절 열들의 데이터 분포, 데이터의 적재 속도, 업무 특성``` 등이다. <br><br>

> ***💡 실무적인 SQL 튜닝 절차*** <br>
① SQL문 실행 결과 & 현황 파악 <br>
② 가시적 / 비가시적 파악 <br>
③ 튜닝 방향 판단 & 개선/적용

<br>

### 기본 키를 변형하는 나쁜 SQL 문
---
**튜닝 전 수행 결과** <br>
```
SELECT *
FROM 사원
WHERE SUBSTRING(사원번호,1,4) = 1100
AND LENGTH(사원번호) = 5;

10 rows in set (0.25sec)
```
→ SUBSTRING이나 LENGTH를 사용하게 된다면 기본 키를 사용하지 않고 테이블 풀 스캔을 수행하게 된다. <br><br>

**튜닝 후 수행 결과** <br>
```
SELECT *
FROM 사원
WHERE 사원번호 BETWEEN 11000 AND 11009

10 rows in set (0.00sec)
```
→ BETWEEN, 비교 연산자를 사용하면 사원번호가 변형되지 않아 기본키나 인덱스를 활용할 수 있게 된다. <br><br>

### 사용하지 않는 함수를 포함하는 나쁜 SQL 문
---
**튜닝 전 수행 결과** <br>
```
SELECT IFNULL(성별, 'NO DATA') AS 성별, COUNT(1) 건수
FROM 사원
GROUP BY IFNULL(성별, 'NO DATA');

2 rows in set (0.391sec)
```
→ 인덱스 풀 스캔 방식 사용 / 성별 칼럼에는 NULL이 존재하지 않음 (=IFNULL 불필요) <br><br>

**튜닝 후 수행 결과** <br>
```
SELECT 성별, COUNT(1) 건수
FROM 사원
GROUP BY 성별

2 rows in set (0.063sec)
```
→ IFNULL() 함수를 처리하려고 DB 내부에 ***별도 임시 테이블을 만들 필요가 없음***

### 형변환으로 인덱스를 활용하지 못하는 나쁜 SQL 문
---
**튜닝 전 수행 결과** <br>
```
SELECT COUNT(*)
FROM 급여
WHERE 사용여부 = 1;

1 rows in set (1.171sec)
```
→ ***테이블 구조 확인 필수!*** <br>
급여 테이블의 사용여부 열을 확인해보면 char(1) 데이터 유형으로 구성되어 있다. 하지만 위 SQL문에서는 숫자 유형을 썼기 때문에 DBMS 내부의 **묵시적 형변환**이 발생했던 것! <br>
✅ 인덱스를 제대로 활용하지 못하고 전체 데이터를 스캔하게 된 것!
<br>

**튜닝 후 수행 결과** <br>
```
SELECT COUNT(*)
FROM 급여
WHERE 사용여부 = '1';

1 rows in set (0.015sec)
```

<br>

### 열을 결합하여 사용하는 나쁜 SQL문
---
**튜닝 전 수행 결과** <br>
```
SELECT *
FROM 사원
WHERE CONCAT(성별, ' ', 성) = 'M Radwan';

102 rows in set (0.188sec)
```

<br>

**튜닝 후 수행 결과** <br>
```
SELECT *
FROM 사원
WHERE 성별 = 'M' AND 성 = 'Radwan';

102 rows in set (0.000sec)
```
→ 성별 칼럼과 성 칼럼을 이용하여 생성된 인덱스가 존재한다. 따라서 인덱스를 잘 활용하면 더 빠르게 조회가 가능하다. <br><br>

### 습관적으로 중복을 제거하는 나쁜 SQL 문
---
**튜닝 전 수행 결과** <br>
```
SELECT DISTINCT 사원.사원번호, 사원.이름, 사원.성, 부서관리자.부서번호
FROM 사원
JOIN 부서관리자
ON (사원. 사원번호 = 부서관리자.사원번호)

24 rows in set (0.000sec)
```
→ DISTINCT 수행을 위해 별도의 임시 테이블을 생성하게 된다. <br><br>

**튜닝 후 수행 결과** <br>
```
SELECT 사원.사원번호, 사원.이름, 사원.성, 부서관리자.부서번호
FROM 사원
JOIN 부서관리자
ON (사원. 사원번호 = 부서관리자.사원번호)

24 rows in set (0.000sec)
```
→ 사원.사원번호는 기본키에 해당하기 때문에 굳이 DISTINCT라는 키워드로 정렬 작업을 하고 중복을 제거하는 작업이 필요하지 않다. <br>
> 💡 ***DISTINCT 키워드*** <br><br>
DISTINCT 키워드는 나열된 열들을 <u>정렬</u>한 뒤 중복된 데이터는 삭제한다. <br>
따라서 DISTINCT를 쿼리에 작성하는 것만으로도 정렬 작업이 포함됨을 인지해야 한다.

### 다수 쿼리를 UNION 연산자로만 합치는 나쁜 SQL 문
---
**튜닝 전 수행 결과** <br>
```
SELECT 'M' AS 성별, 사원번호
FROM 사원
WHERE 성별 = 'M'
AND 성='Baba'

UNION

SELECT 'F', 사원번호
FROM 사원
WHERE 성별 = 'F'
AND 성 = 'Baba';

226 rows in set (0.000sec)
```
→ 임시 테이블을 생성하고 그 내부에서 각 결과(두 개의 SELECT문)의 UNION 연산 작업을 수행하고 있다고 예상할 수 있다. <br>
※ 만약 두 SELECT문의 결과가 메모리에 상주하기 어려울 만큼 많다면 메모리가 아닌 <u>디스크에 임시 파일을 생성</u>하여 UNION 작업을 하게 된다. <br><br>

**튜닝 후 수행 결과** <br>
```
SELECT 'M' AS 성별, 사원번호
FROM 사원
WHERE 성별 = 'M'
AND 성='Baba'

UNION ALL

SELECT 'F', 사원번호
FROM 사원
WHERE 성별 = 'F'
AND 성 = 'Baba';

226 rows in set (0.000sec)
```
→ 이미 두 SELECT 문은 중복되는 데이터가 없기 때문에 UNION을 써서 한 번 더 중복을 제거할 필요가 없다. <br>
UNION ALL을 사용한다면 정렬하여 중복을 제거하는 작업이 제외되면서 **불필요한 리소스 낭비를 방지**할 수 있다. <br><br>
> 📢 ***이미 중복 데이터가 없기 때문에 UNION ALL을 사용하는 것이 더 효율적인 것!!*** <br> 
→→ 중복 데이터 존재 여부를 미리 잘 파악해야 한다!! 

<br>

### 인덱스 고려 없이 열을 사용하는 나쁜 SQL 문
---
**튜닝 전 수행 결과** <br>
```
SELECT 성, 성별, COUNT(1) AS 카운트
FROM 사원
GROUP BY 성, 성별;

500 rows in set (0.641sec)
```
→ 현재 인덱스는 성별, 성 순서로 되어 있기 때문에 인덱스의 결과를 다시 성 열과 성별 열 순으로 재정렬하고 있다. <br><br>

**튜닝 후 수행 결과** <br>
```
SELECT 성, 성별, COUNT(1) AS 카운트
FROM 사원
GROUP BY 성별, 성;

500 rows in set (0.015sec)
```

<br>

### 엉뚱한 인덱스를 사용하는 나쁜 SQL 문
---
**튜닝 전 수행 결과** <br>
```
SELECT 사원번호
FROM 사원
WHERE 입사일자 LIKE '1989%'
AND 사원번호 > 100000;

20001 rows in set (0.015sec)
```
**[고민 1]** <br>
→ 사원번호가 100000보다 큰 데이터는 210024건이 있고, 입사일자가 1989년도인 데이터는 총 28394이다. <br>
스토리지 엔진에서 데이터에 접근할 때 사원번호 열로 구성된 기본 키로 액세스하는 게 과연 효율적일지 고민해야 한다. <br>
🚨 ***하지만 인덱스 루스 스캔 방식(듬성듬성하게 인덱스를 읽는 것)에 의해 인덱스를 스킵하는 오버헤드가 발생할 수 있다.*** <br><br>

**[고민 2]** <br>
→ 입사일자 열의 데이터 유형은 당연히 date 타입이다. <br>
이때 부분 검색이 목적인 LIKE 절을 사용하는 것은 적절하지 않을 수 있다. <br><br>

**튜닝 후 수행 결과** <br>
```
SELECT 사원번호
FROM 사원
WHERE 입사일자 >= '1989-01-01' AND 입사일자 < '1990-01-01'
AND 사원번호 > 100000;

20001 rows in set (0.000sec)
```
→ 부등호(>, <, <=, >=) 조건절이 우선하여 인덱스를 사용하므로 데이터 접근 범위를 줄일 수 있다. <br>
테이블에 접근하지 않고 I_입사일자 인덱스만 사용하여 결과를 출력하는데 이를 <u>커버링 인덱스 스캔</u>이라고 부른다. <br>
✅ ***스토리지 엔진에서 데이터에 접근할 때 데이터를 적게 가져오는 것이 효율적이다!*** <br><br>

