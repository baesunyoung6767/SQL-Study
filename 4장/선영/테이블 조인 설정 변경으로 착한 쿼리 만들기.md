## 테이블 조인 설정 변경으로 착한 쿼리 만들기
Mysql과 MariaDB에서 두 개 테이블의 데이터를 결합하는 조인 알고리즘은 대부분 **중첩 루프 조인**으로 풀린다. <br><br>

### 작은 테이블이 먼저 조인에 참여하는 나쁜 SQL 문
---
**튜닝 전 수행 결과** <br>
```
SELECT 매핑.사원번호, 부서.부서번호
FROM 부서사원_매핑 매핑, 부서
WHERE 매핑.부서번호 = 부서.부서번호
AND 매핑.시작일자 >= '2002-03-01';

1341 rows in set (1.078sec)
```
→ 데이터 수가 적은 부서 테이블이 드라이빙 테이블이 되는데 드리븐 테이블인 부서사원_매핑 테이블에서 인덱스 스캔을 하고 랜덤 액세스가 발생하여 비효율적이다. <br>
또한 부서사원_매핑 테이블에는 30만 건 이상의 데이터가 있으나 MySQL 엔진으로 가져온 모든 데이터에 대해 WHERE 절의 필터 조건을 수행한다. <br>

**튜닝 후 수행 결과** <br>
```
SELECT STRAIGHT_JOIN 매핑.사원번호, 부서.부서번호
FROM 부서사원_매핑 매핑, 부서
WHERE 매핑.부서번호 = 부서.부서번호
AND 매핑.시작일자 >= '2002-03-01';

1341 rows in set (0.062sec)
```
>📢 ***STRAIGHT_JOIN*** <br>
FROM 절에 작성된 테이블 순서대로 조인에 참여할 수 있도록 고정

→ 먼저 접근하는 드라이빙 테이블은 부서사원_매핑 테이블로, 테이블의 랜덤 액세스 없이 테이블 풀 스캔으로 한 번에 다수의 페이지에 접근한다. 그리고 <u>드라이빙 테이블에서 추출된 데이터만큼 반복하여 접근</u>하게 되는 드리븐 테이블은 부서 테이블이 된다. <br>
+) 부서 테이블의 기본 키가 부서 번호이기 때문에 기본 키로 반복 접근하여 부서 테이블에서는 1개의 데이터에만 접근하고 있다.

<br>

### 메인 테이블에 계속 의존하는 나쁜 SQL문<br>
---
**튜닝 전 수행 결과** <br>
```
SELECT 사원.사원번호, 사원.이름, 사원.성
FROM 사원
WHERE 사원번호 > 450000
AND (SELECT MAX(연봉)
	FROM 급여
		WHERE 사원번호 = 사원.사원번호
	) > 100000;

3155 rows in set (0.250sec)
```
→ 외부의 사원 테이블로부터 조건절을 전달받아 수행해야 하는 <u>의존성을 가진 서브쿼리</u>이다. <br>
>📢 ***서브쿼리보다는 조인으로 수행하는 편이 성능 측면에서 유리할 가능성이 높다!***

<br>

**튜닝 후 수행 결과** <br>
```
SELECT 사원.사원번호,
	사원.이름,
	사원.성
FROM 사원, 급여
WHERE 사원.사원번호 > 450000
AND 사원.사원번호 = 급여.사원번호
GROUP BY 사원.사원번호
HAVING MAX(급여.연봉) > 100000;

3155 rows in set (0.110sec)
```

<br>

### 불필요한 조인을 수행하는 나쁜 SQL 문
---
**튜닝 전 수행 결과** <br>
```
SELECT COUNT(DISTINCT 사원.사원번호) AS 데이터건수
FROM 사원, 
	(SELECT 사원번호
    FROM 사원출입기록 기록
    WHERE 출입문 = 'A'
    ) 기록
WHERE 사원.사원번호 = 기록.사원번호;

1 rows in set (1.062sec)
```
→ 기록 테이블의 데이터는 사원 테이블에 해당 데이터들이 각각 존재하는지 여부만 파악하면 된다.

<br>

**튜닝 후 수행 결과** <br>
```
SELECT COUNT(1) AS 데이터건수
FROM 사원
WHERE EXISTS (SELECT 1 
	FROM 사원출입기록 기록
    WHERE 출입문 = 'A'
    AND 기록.사원번호 = 사원.사원번호);

1 rows in sett (0.687sec)
```