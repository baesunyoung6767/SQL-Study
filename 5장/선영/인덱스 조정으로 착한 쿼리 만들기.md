## 인덱스 조정으로 착한 쿼리 만들기

### 인덱스 없이 작은 규모의 데이터를 조회하는 나쁜 SQL문
---
**튜닝 전 수행 결과**<br>
```
SELECT *
FROM 사원
WHERE 이름 = 'Georgi'
AND 성 = 'Wielonsky';

1 rows in set (0.250sec)
```
→ 테이블 풀 스캔하여 데이터 가져온다. <br>

**튜닝 후 수행 결과**<br>
```
ALTER TABLE 사원
ADD INDEX I_사원_성_이름 (성, 이름);

SELECT *
FROM 사원
WHERE 이름 = 'Georgi'
AND 성 = 'Wielonsky';

1 rows in set (0.016sec)
```
→ 성 열의 데이터가 이름 열의 데이터보다 많기 때문에 데이터 범위를 더 축소할 수 있는 성 열을 선두 열로 삼아 인덱스를 생성한다. <br><br>

### 인덱스를 하나만 사용하는 나쁜 SQL 문
---
**튜닝 전 SQL문**<br>
```
SELECT *
FROM 사원
WHERE 이름 = 'Matt'
OR 입사일자 = '1987-03-31';

343 rows in set (0.250sec)
```
→ 소량의 데이터를 가져올 때는 인덱스 스캔이 효율적이지만 입사일자 열이 포함된 인덱스는 있지만 이름 열이 포함된 인덱스는 존재하지 않아 테이블 풀 스캔으로 처리되고 있다. <br>

**튜닝 후 SQL문** <br>
```
ALTER TABLE 사원
ADD INDEX I_이름(이름);

SELECT *
FROM 사원
WHERE 이름 = 'Matt'
OR 입사일자 = '1987-03-31';

343 rows in set (0.016sec)
```
→ 2개의 조건절 열이 각각 인덱스 스캔으로 수행되고 각 결과는 병합된다.(= type : index_merge) <br><br>

✅ 만약에 WHERE 절 ~ OR 구문에서 한쪽의 조건절이 동등 조건이 아닌 **범위 조건(LIKE, BETWEEN 구문)이라면 index_merge로 처리되지 않을 수 있다.** 버전에 따라 내부 메커니즘에 차이가 있으므로 실행 계획을 확인한 뒤 UNION이나 UNION ALL 구문 등으로 분리하는 걸 고려해야 한다. <br>
→ 하지만 index_merge 또한 인덱스를 병합하는 과정에서 오히려 시간이 오래 걸려 비효율적인 상황도 있다고 하니 잘 알아보고 사용해야 할 것 같다!

> 💡 ***index merge*** <br>
두 개의 인덱스를 동시에 사용해서 하나의 인덱스를 사용할 때보다 더 큰 시너지 효과를 볼 수 있게 하는 스캔 방법

> 💡 ***동등 조건일 때 index_merge로 처리되는 이유는 <u>우선 순위가 동일</u>하기 때문이다.*** <br><br>

### 큰 규모의 데이터 변경으로 인덱스에 영향을 주는 나쁜 SQL문
---
**튜닝 전 수행 결과** <br>
```
UPDATE 사원출입기록
SET 출입문 = 'X'
WHERE 출입문 = 'B';

300000 rows in set (14.234sec)
```
→ <u>조회한 데이터를 변경하는 범위에는 테이블뿐만 아니라 인덱스도 포함</u>되므로 인덱스가 많은 테이블의 데이터를 변경할 때는 성능적으로 불리하다. <br>
사원출입기록 테이블과 같은 이력용 테이블에서는 보통 지속적인 데이터 저장만 이루어지므로, 출입문 인덱스의 활용도가 없다면 삭제할 것을 고려해야 한다. <br><br>

**튜닝 후 수행 결과** <br>
```
UPDATE 사원출입기록
SET 출입문 = 'X'
WHERE 출입문 = 'B';

ALTER TABLE 사원출입기록
DROP INDEX I_출입문;

300000 rows in set (8.375sec)
```

<br><br>

### 비효율적인 인덱스를 사용하는 나쁜 SQL문
---
**튜닝 전 수행 결과** <br>
```
SELECT 사원번호, 이름, 성
FROM 사원
WHERE 성별 = 'M'
AND 성 = 'Baba'

135 rows in set (0.015sec)
```
→ 성별 열의 데이터는 단 2건에 불과하지만 인덱스를 조회해보면 성별 열이 성 열보다 선두로 있다. <br>
``` 인덱스 : I_성별_성 = 구성 컬럼 : 성별, 성``` <br>
<u>데이터가 다양하지 않은 성별 열을 선두로 구성한 인덱스가 과연 효율적일지</u> 고민해봐야 한다. <br>

**튜닝 후 수행 결과** <br>
```
SELECT 사원번호, 이름, 성
FROM 사원
WHERE 성별 = 'M'
AND 성 = 'Baba';

ALTER TABLE 사원
DROP INDEX I_성별_성,
ADD INDEX I_성_성별(성, 성별);

135 rows in set (0.000sec)
```
→ 더 다양한 종류의 값(1,638개)을 가지고 있는 성 열을 먼저 활용하면 데이터 접근 범위를 상당히 줄일 수 있다. <br>
따라서 기존 인덱스를 삭제하고 '성+성별' 순서의 인덱스를 새로 생성하여 튜닝을 수행하였다.