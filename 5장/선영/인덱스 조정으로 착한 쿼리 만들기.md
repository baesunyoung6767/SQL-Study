## 인덱스 조정으로 착한 쿼리 만들기

### 인덱스 없이 작은 규모의 데이터를 조회하는 나쁜 SQL문
---
**튜닝 전 수행 결과**<br>
```
SELECT *
FROM 사원
WHERE 이름 = 'Georgi'
AND 성 = 'Wielonsky';

1 rows in set (0.250sec)
```
→ 테이블 풀 스캔하여 데이터 가져온다. <br>

**튜닝 후 수행 결과**<br>
```
ALTER TABLE 사원
ADD INDEX I_사원_성_이름 (성, 이름);

SELECT *
FROM 사원
WHERE 이름 = 'Georgi'
AND 성 = 'Wielonsky';

1 rows in set (0.016sec)
```
→ 성 열의 데이터가 이름 열의 데이터보다 많기 때문에 데이터 범위를 더 축소할 수 있는 성 열을 선두 열로 삼아 인덱스를 생성한다. <br><br>

### 인덱스를 하나만 사용하는 나쁜 SQL 문
---
**튜닝 전 SQL문**<br>
```
SELECT *
FROM 사원
WHERE 이름 = 'Matt'
OR 입사일자 = '1987-03-31';

343 rows in set (0.250sec)
```
→ 소량의 데이터를 가져올 때는 인덱스 스캔이 효율적이지만 입사일자 열이 포함된 인덱스는 있지만 이름 열이 포함된 인덱스는 존재하지 않아 테이블 풀 스캔으로 처리되고 있다. <br>

**튜닝 후 SQL문** <br>
```
ALTER TABLE 사원
ADD INDEX I_이름(이름);

SELECT *
FROM 사원
WHERE 이름 = 'Matt'
OR 입사일자 = '1987-03-31';

343 rows in set (0.016sec)
```
→ 2개의 조건절 열이 각각 인덱스 스캔으로 수행되고 각 결과는 병합된다.(= type : index_merge) <br><br>

✅ 만약에 WHERE 절 ~ OR 구문에서 한쪽의 조건절이 동등 조건이 아닌 **범위 조건(LIKE, BETWEEN 구문)이라면 index_merge로 처리되지 않을 수 있다.** 버전에 따라 내부 메커니즘에 차이가 있으므로 실행 계획을 확인한 뒤 UNION이나 UNION ALL 구문 등으로 분리하는 걸 고려해야 한다. <br>
→ 하지만 index_merge 또한 인덱스를 병합하는 과정에서 오히려 시간이 오래 걸려 비효율적인 상황도 있다고 하니 잘 알아보고 사용해야 할 것 같다!

> 💡 ***index merge*** <br>
두 개의 인덱스를 동시에 사용해서 하나의 인덱스를 사용할 때보다 더 큰 시너지 효과를 볼 수 있게 하는 스캔 방법

> 💡 ***동등 조건일 때 index_merge로 처리되는 이유는 <u>우선 순위가 동일</u>하기 때문이다.***